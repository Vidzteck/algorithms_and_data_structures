**Анализ кода приближенного алгоритма вершинного покрытия**


---

# 0) Определение алгоритма

Жадный алгоритм — алгоритм, заключающийся в принятии локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным. Известно, что если структура задачи задается матроидом, тогда применение жадного алгоритма выдаст глобальный оптимум.

---

# 1) Анализ кода с ссылками на операторы

Рассмотрим функцию `greedy_vertex_cover`, которая реализует жадный алгоритм.

*   `cover = set()` (строка 8): Инициализируется пустое множество `cover`. Это множество будет содержать вершины, выбранные для приближенного вершинного покрытия. Использование `set` позволяет эффективно добавлять элементы и проверять их принадлежность.
*   `remaining_edges = set(edges)` (строка 9): Входной список ребер `edges` преобразуется в множество `remaining_edges`. Это позволяет эффективно удалять элементы в будущем с помощью `pop()` и перебирать оставшиеся ребра.
*   `while remaining_edges:` (строка 11): Начинается основной цикл алгоритма. Цикл продолжается до тех пор, пока в множестве `remaining_edges` есть хотя бы одно ребро. Это означает, что пока существуют непокрытые ребра, алгоритм продолжает работать.
*   `u, v = remaining_edges.pop()` (строка 13): Из множества `remaining_edges` извлекается и удаляется произвольное ребро `(u, v)`. Метод `pop()` удаляет и возвращает один элемент из множества. Это текущее ребро, которое необходимо покрыть.
*   `cover.add(u)` и `cover.add(v)` (строки 16, 17): Обе вершины `u` и `v` текущего ребра `(u, v)` добавляются в множество `cover`. Это жадный шаг: алгоритм "покрывает" выбранное ребро, добавляя обе его вершины в покрытие.
*   `remaining_edges = {(a, b) for a, b in remaining_edges if a != u and a != v and b != u and b != v}` (строка 20): Создается новое множество `remaining_edges`, которое включает только те ребра из *старого* `remaining_edges`, которые **не** инцидентны вершинам `u` или `v`. Это означает, что все ребра, которые теперь покрыты (т.е. содержат вершину `u` или `v`), исключаются из рассмотрения. Этот шаг обновляет список непокрытых ребер.
*   `return cover` (строка 21): После завершения цикла (когда `remaining_edges` становится пустым), функция возвращает найденное множество вершин `cover`, которое представляет собой вершинное покрытие.

---

# 2) Временная сложность O(n)

Временная сложность реализованного алгоритма составляет **O(n²)**, где `n` — количество ребер в графе.

---

# 3) Почему такая временная сложность

*   **Основные переменные:** Пусть `n` — количество ребер в исходном графе (в нашем случае `n = 10`). Пусть `V` — количество вершин (`V = 10`).
*   **Цикл `while`:** Цикл `while remaining_edges:` (строка 11) может выполниться не более `n` раз, так как на каждой итерации мы удаляем хотя бы одно ребро (`pop` на строке 13).
*   **Операции внутри цикла:**
    *   `remaining_edges.pop()` (строка 13): O(1) - извлечение произвольного элемента из множества.
    *   `cover.add(u)` и `cover.add(v)` (строки 16, 17): O(1) (амортизированно) - добавление элемента в множество.
    *   **Самая "дорогая" операция:** `remaining_edges = {(a, b) for a, b in remaining_edges if ...}` (строка 20). Этот генератор множества проходит по *всем* ребрам, оставшимся в *текущем* множестве `remaining_edges`, и проверяет условие `a != u and a != v and b != u and b != v` для каждого ребра. В худшем случае (например, в начале выполнения, когда `remaining_edges` содержит все `n` ребер), этот генератор выполнит `n` проверок. В последующих итерациях количество ребер в `remaining_edges` уменьшается, но в худшем случае каждая итерация может занять до O(n) времени.
*   **Общая сложность:** Поскольку цикл может выполниться до `n` раз, и *внутри* каждой итерации может выполняться операция, занимающая O(n), общая временная сложность составляет O(n) * O(n) = **O(n²)**.

Эта квадратичная сложность обусловлена неэффективным способом обновления списка непокрытых ребер (создание нового множества каждый раз). Более эффективная реализация могла бы использовать структуры данных для быстрого удаления всех ребер, инцидентных вершинам `u` и `v`, например, список смежности или отдельные множества для каждого ребра.

---

# 4) Ответ на контрольный вопрос 

Приближенный алгоритм — это алгоритм, который находит **не оптимальное**, а **достаточно хорошее** решение для NP-сложной задачи **за полиномиальное время**. Его основная цель — **пожертвовать абсолютной точностью ради практической вычислительной осуществимости**, при этом **гарантируя**, что найденное решение не будет слишком хуже оптимального (например, не более чем в 2 раза).

---
