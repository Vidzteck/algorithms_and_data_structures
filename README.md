# Рекурсивный переворот строки — Анализ сложности

## Описание функции

Реализована рекурсивная функция `reverse_string(s)`, которая принимает строку `s` и возвращает её в обратном порядке.

```markdown
def reverse_string(s):
    # Базовый случай: если строка пустая или состоит из одного символа
    if len(s) <= 1:
        return s
    # Рекурсивный случай: последний символ + рекурсивный вызов для остальной части
    return s[-1] + reverse_string(s[:-1])

# Тестирование
test_str = "hello"
print(f"Оригинал: {test_str}")
print(f"Перевёрнутая: {reverse_string(test_str)}")
```

## Анализ кода

### Базовый случай
```python
if len(s) <= 1:
    return s
```
- Проверка длины строки и возврат результата выполняются за **O(1)**.

### Рекурсивный случай
```python
return s[-1] + reverse_string(s[:-1])
```
- Получение последнего символа `s[-1]` — **O(1)**.
- Создание подстроки `s[:-1]` — **O(n)**, так как строки в Python неизменяемы, и операция среза создаёт **новую строку**, копируя все символы, кроме последнего.
- Конкатенация `s[-1] + reverse_string(...)` — также **O(k)**, где `k` — длина результирующей строки на текущем шаге (в худшем случае ≈ n).

### Глубина рекурсии
- Функция вызывает себя для строк длиной `n−1`, `n−2`, ..., `0`.
- Общая глубина рекурсии: **O(n)**.

### Работа на каждом уровне рекурсии
- На уровне `i` (начиная с длины `n` и уменьшаясь до `1`) выполняются операции копирования строк объёмом `O(n − i)`.
- Следовательно, стоимость одного уровня — линейна относительно текущей длины строки.

### Общая временная сложность
Суммируем стоимость всех уровней рекурсии:
\[T(n) = O(n) + O(n-1) + O(n-2) + \dots + O(1) = O\left(\frac{n(n+1)}{2}\right) = O(n^2)\]

## Почему сложность O(n²)?

Хотя рекурсия выполняется **линейное** число раз (**n**), на **каждом шаге** происходят **линейные** операции над строками из-за их **неизменяемой природы** в Python (аналогично в Java и C++ при использовании стандартных строк). Это приводит к **квадратичной** общей временной сложности — **O(n²)**.

> **Важно:** если бы использовался изменяемый контейнер (например, список символов, передаваемый по ссылке), и функция работала бы *in-place*, временная сложность могла бы быть снижена до **O(n)**. Однако в данной реализации — **O(n²)**.

## Вывод

Несмотря на простоту и элегантность рекурсивного подхода, **неэффективная работа со строками** делает алгоритм существенно **медленнее** итеративного аналога, который также может перевернуть строку за **O(n)** с использованием списков или двух указателей.
```
